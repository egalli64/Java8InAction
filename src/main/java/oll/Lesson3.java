/**
 * Copyright Â© 2014, Oracle and/or its affiliates. All rights reserved.
 *
 * JDK 8 MOOC Lesson 3 homework
 * 
 * Solution by Manny egalli64@gmail.com
 */
package oll;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * @author Simon Ritter (@speakjava)
 * @author Stuart Marks
 */
public class Lesson3 {
    /* How many times to repeat the test. 5 seems to give reasonable results */
    private static final int RUN_COUNT = 5;

    /**
     * Used by the measure method to determine how long a Supplier takes to return a
     * result.
     *
     * @param <T>
     *            The type of the result provided by the Supplier
     * @param label
     *            Description of what's being measured
     * @param supplier
     *            The Supplier to measure execution time of
     * @return
     */
    static <T> T measureOneRun(String label, Supplier<T> supplier) {
        long startTime = System.nanoTime();
        T result = supplier.get();
        long endTime = System.nanoTime();
        System.out.printf("%s took %dms%n", label, (endTime - startTime + 500_000L) / 1_000_000L);
        return result;
    }

    /**
     * Repeatedly generate results using a Supplier to eliminate some of the issues
     * of running a micro-benchmark.
     *
     * @param <T>
     *            The type of result generated by the Supplier
     * @param label
     *            Description of what's being measured
     * @param supplier
     *            The Supplier to measure execution time of
     * @return The last execution time of the Supplier code
     */
    static <T> T measure(String label, Supplier<T> supplier) {
        T result = null;

        for (int i = 0; i < RUN_COUNT; i++)
            result = measureOneRun(label, supplier);

        return result;
    }

    /**
     * Computes the Levenshtein distance between every pair of words in the subset,
     * and returns a matrix of distances. This actually computes twice as much as it
     * needs to, since for every word a, b it should be the case that lev(a,b) ==
     * lev(b,a) i.e., Levenshtein distance is commutative.
     *
     * @param words
     *            The subset of words whose distances to compute
     * @param parallel
     *            Whether to run in parallel
     * @return Matrix of Levenshtein distances
     */
    static int[][] computeLevenshtein(List<String> words, boolean parallel) {
        final int SIZE = words.size();
        int[][] distances = new int[SIZE][SIZE];
        IntStream stream = IntStream.range(0, SIZE);

        if (parallel)
            stream = stream.parallel(); // Convert the stream to a parallel one

        stream.forEach(i -> {
            for (int j = 0; j < SIZE; j++)
                distances[i][j] = Levenshtein.lev(words.get(i), words.get(j));
        });

        return distances;
    }

    /**
     * Process a list of random strings and return a modified list
     * 
     * @param words
     *            The subset of words whose distances to compute
     * @param parallel
     *            Whether to run in parallel
     * @return The list processed in whatever way you want
     */
    static List<String> processWords(List<String> words, boolean parallel) {
        Stream<String> stream;

        if (parallel)
            stream = words.parallelStream();
        else
            stream = words.stream();

        return stream.map(String::toLowerCase).filter(s -> s.startsWith("a")).sorted().distinct()
                .collect(Collectors.toList());
    }

    /**
     * Main entry point for application
     *
     * @param args
     *            the command line arguments
     * @throws IOException
     *             If word file cannot be read
     */
    public static void main(String[] args) throws IOException {
        RandomWords rws = new RandomWords();
        List<String> words = rws.createList(1000);

        measure("Sequential", () -> computeLevenshtein(words, false));
        measure("Parallel", () -> computeLevenshtein(words, true));

         measure("Sequential", () -> processWords(words, false));
         measure("Parallel", () -> processWords(words, true));
    }
}

/**
 * Class to generate a list of random words
 *
 * @author Simon Ritter (@speakjava)
 * @author Manny egalli64@gmail.com access file through getResource() and other
 *         minor changes
 */
class RandomWords {
    private static final String FILE_WORDS = Lesson3.class.getResource("/oll/words").getPath();
    private final List<String> words;

    /**
     * Constructor
     * 
     * @throws IOException
     *             If the source words file cannot be read
     */
    public RandomWords() throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(FILE_WORDS))) {
            words = reader.lines().collect(Collectors.toList());
            System.out.println("Loaded " + words.size() + " words");
        }
    }

    /**
     * Create a list of a given size containing random words
     *
     * @param size
     *            The size of the list to create
     * @return The created list
     */
    public List<String> createList(int size) {
        Random rand = new Random();
        return rand.ints(size, 0, words.size()).mapToObj(words::get).collect(Collectors.toList());
    }

    /**
     * Return the list of all source words, which cannot be modified
     *
     * @return The unmodifiable list of all source words
     */
    public List<String> allWords() {
        return Collections.unmodifiableList(words);
    }
}

/**
 * Look at Wikipedia for more detail on calculating Levenshtein distances
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * 
 * @author Simon Ritter (@speakjava)
 * @author Manny minor cleanup
 */
class Levenshtein {
    /**
     * Utility method to return the minimum of three integers
     * 
     * @param i0
     *            The first integer
     * @param i1
     *            The second integer
     * @param i2
     *            The third integer
     * @return The minimum of the three parameters
     */
    static int min3(int i0, int i1, int i2) {
        return Math.min(i0, Math.min(i1, i2));
    }

    /**
     * Compute the Levenshtein distance between Strings stringA and stringB,
     * respecting supplementary characters (i.e., surrogate pairs). The algorithm is
     * the two-row technique from:
     *
     * https://en.wikipedia.org/wiki/Levenshtein_distance
     *
     * which is derived from Hjelmqvist, Sten (26 Mar 2012), Fast, memory efficient
     * Levenshtein algorithm:
     * 
     * http://www.codeproject.com/Articles/13525/Fast-memory-efficient-Levenshtein-algorithm
     *
     * @param lhs
     *            left-hand side string, must be non-null
     * @param rhs
     *            right-hand side string, must be non-null
     * @return the Levenshtein distance between the two strings
     * @throws NullPointerException
     *             if either string is null
     */
    static int lev(String lhs, String rhs) {
        // handle degenerate cases
        if (lhs.equals(rhs))
            return 0;
        if (lhs.length() == 0)
            return rhs.length();
        if (rhs.length() == 0)
            return lhs.length();

        // convert strings to code points, represented as int[]
        int[] s = lhs.codePoints().toArray();
        int[] t = rhs.codePoints().toArray();

        // create work vectors
        int[] v0 = new int[t.length + 1];
        int[] v1 = new int[t.length + 1];
        Arrays.setAll(v0, i -> i);

        for (int i = 0; i < s.length; i++) {
            // calculate v1 (current row distances) from the previous row v0
            // first element of v1 is A[i+1][0]
            // edit distance is delete (i+1) chars from s to match empty t
            v1[0] = i + 1;

            // use formula to fill in the rest of the row
            for (int j = 0; j < t.length; j++) {
                int cost = (s[i] == t[j]) ? 0 : 1;
                v1[j + 1] = min3(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
            }

            // copy v1 (current row) to v0 (previous row) for next iteration
            Arrays.setAll(v0, j -> v1[j]);
        }

        return v1[t.length];
    }
}
